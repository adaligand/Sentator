<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6196157933137237"
     crossorigin="anonymous"></script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tic Tac Toe</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<style>
    body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f9;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
    }
    
    .game-wrapper {
        background-color: white;
        padding: 20px 40px;
        border-radius: 15px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        text-align: center;
    }

    #container { display: flex; justify-content: center; align-items: flex-start; gap: 20px; }
    #grid { display: grid; gap: 10px; }
    .cell { 
        position: relative; 
        width: 150px;  
        height: 150px;  
        border: 1px solid #999; 
        border-radius: 10px; 
        cursor: pointer; 
        background-color: #fafafa;
    }
    
    .cell-text {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 18px;
        font-weight: bold;
        padding: 5px;
        box-sizing: border-box;
        color: #333;
        pointer-events: none; /* ✅ This allows drop events to pass through to the parent cell */
    }
    .overlay { 
        position: absolute; 
        top:0; left:0; 
        width:100%; height:100%; 
        background-color: rgba(255,0,0,0.4); 
        opacity:0; 
        border-radius:10px; 
        transition: opacity 0.3s; 
        pointer-events: none; 
    }
    .mark {
        position:absolute;
        top:0; left:0;
        width:100%; height:100%;
        display:flex;
        justify-content:center;
        align-items:center;
        font-size:120px;
        font-weight:bold;
        color:rgba(249, 249, 8, 0.871); 
        pointer-events:none;
        user-select:none;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    #words { display:flex; flex-direction: column; gap:10px; }
    .word { 
        padding: 10px; 
        border:1px solid #ccc; 
        border-radius:5px; 
        cursor: grab; 
        background-color:#f0f0f0; 
        user-select:none; 
        width: 180px;
        font-size: 16px;
        text-align: center;
        box-sizing: border-box;
        touch-action: none; /* ADDED: Prevents page scrolling on touch devices */
    }
    .word.dragging { /* ADDED: Style for the element being dragged */
        opacity: 0.5;
    }
    #turn { margin-top:20px; font-size:20px; font-weight:bold; }
    #restart { 
        margin-top:15px; 
        padding:8px 15px; 
        font-size:16px; 
        border:1px solid #ccc; 
        border-radius:5px; 
        background-color:#f0f0f0; 
        cursor:pointer; 
        display:none;
    }
</style>
</head>
<body>

<div class="game-wrapper">
    <h1>Tic Tac Toe</h1>
    <div id="container">
        <div id="grid"></div>
        <div id="words"></div>
    </div>
    <div id="turn">Turn: X</div>
    <button id="restart">Restart Game</button>
</div>

<script>
let allItemPairs = [];
let turn = 'X';
let gameOver = false;
let draggedItem = null; // ADDED: To track the item being dragged for touch events

const grid = document.getElementById('grid');
const wordsDiv = document.getElementById('words');
const turnDiv = document.getElementById('turn');
const restartBtn = document.getElementById('restart');
const containerDiv = document.getElementById('container');

const params = new URLSearchParams(window.location.search);
const sheetUrl = params.get('sheet');

if (!sheetUrl) {
    document.querySelector('.game-wrapper').innerHTML = "<h1>⚠️ No sheet URL provided.</h1>";
} else {
    Papa.parse(sheetUrl, {
        download: true,
        header: false,
        skipEmptyLines: true,
        complete: function(results) {
            results.data.forEach((row, index) => {
                if (index === 0) return; // Skip header row
                
                if (row[1] && row[2]) {
                    allItemPairs.push({ 
                        term: row[1].trim(),
                        translation: row[2].trim()
                    });
                }
            });

            if (allItemPairs.length < 9) {
                document.querySelector('.game-wrapper').innerHTML = "<h1>⚠️ Not enough data. The game requires at least 9 rows with text in columns B and C.</h1>";
                return;
            }

            generateGame();
        },
        error: function(err) {
            console.error(err);
            document.querySelector('.game-wrapper').innerHTML = "<h1>⚠️ Error loading CSV file.</h1>";
        }
    });
}

function shuffle(array){
    for(let i=array.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [array[i],array[j]]=[array[j],array[i]];
    }
    return array;
}

function checkWinner(){
    const cells = [...document.querySelectorAll('.cell .mark')].map(m=>m.textContent);
    const winPatterns = [
        [0,1,2],[3,4,5],[6,7,8], // rows
        [0,3,6],[1,4,7],[2,5,8], // cols
        [0,4,8],[2,4,6]      // diagonals
    ];
    for(const pattern of winPatterns){
        const [a,b,c] = pattern;
        if(cells[a] && cells[a]===cells[b] && cells[a]===cells[c]){
            turnDiv.textContent = cells[a] + " wins!";
            gameOver = true;
            restartBtn.style.display = "inline-block";
            return true;
        }
    }
    if(cells.every(c=>c)){ // draw
        turnDiv.textContent = "It's a draw!";
        gameOver = true;
        restartBtn.style.display = "inline-block";
    }
    return false;
}

// REFACTORED: Moved the drop logic into its own function to be called by both mouse and touch events
function handleDropLogic(cell, word) {
    if (gameOver) return;
    const mark = cell.querySelector('.mark');
    const overlay = cell.querySelector('.overlay');
    const wordEl = document.querySelector(`.word[data-word='${word}']`);

    if (word === cell.dataset.correctTerm && !mark.textContent) {
        mark.textContent = turn;
        mark.style.color = turn === 'X' ? 'rgba(255,100,100,0.8)' : 'rgba(100,100,255,0.8)';
        if (wordEl) wordEl.remove();
        if (!checkWinner()) {
            turn = turn === 'X' ? 'O' : 'X';
            turnDiv.textContent = 'Turn: ' + turn;
        }
    } else {
        overlay.style.opacity = '0.7';
        setTimeout(() => overlay.style.opacity = '0', 500);
        
        // This part is a bit tricky for touch, as the word element might be hidden.
        // For simplicity, we just switch turns on wrong answers.
        turn = turn === 'X' ? 'O' : 'X';
        turnDiv.textContent = 'Turn: ' + turn;
    }
}


function generateGame(){
    grid.innerHTML = '';
    wordsDiv.innerHTML = '';
    turn = 'X';
    gameOver = false;
    restartBtn.style.display = "none";
    turnDiv.textContent = "Turn: X";

    let selected = shuffle([...allItemPairs]).slice(0,9);

    const columns = 3;
    grid.style.gridTemplateColumns = `repeat(${columns}, 150px)`;

    selected.forEach(pair=>{
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.correctTerm = pair.term;

        const cellText = document.createElement('div');
        cellText.className = 'cell-text';
        cellText.textContent = pair.translation;
        cell.appendChild(cellText);

        const overlay = document.createElement('div');
        overlay.className='overlay';
        cell.appendChild(overlay);

        const mark = document.createElement('div');
        mark.className='mark';
        cell.appendChild(mark);

        // --- MOUSE EVENT (Original) ---
        cell.addEventListener('dragover', e => e.preventDefault());
        cell.addEventListener('drop', e => {
            e.preventDefault();
            const draggedWord = e.dataTransfer.getData('text');
            handleDropLogic(cell, draggedWord); // MODIFIED: Call the refactored function
        });

        grid.appendChild(cell);
    });

    shuffle(selected).forEach(pair=>{
        const wordEl = document.createElement('div');
        wordEl.className='word';
        wordEl.textContent = pair.term;
        wordEl.setAttribute('draggable','true');
        wordEl.dataset.word = pair.term;
        
        // --- MOUSE DRAG EVENT (Original) ---
        wordEl.addEventListener('dragstart',e=>{
            e.dataTransfer.setData('text', pair.term);
            draggedItem = e.target;
            setTimeout(() => e.target.classList.add('dragging'), 0);
        });
        
        wordEl.addEventListener('dragend', e => {
            e.target.classList.remove('dragging');
        });

        // --- ADDED: TOUCH EVENT LISTENERS ---
        wordEl.addEventListener('touchstart', e => {
            e.preventDefault(); // Prevent scrolling
            draggedItem = e.target;
            draggedItem.classList.add('dragging');
        }, { passive: false });
        
        wordsDiv.appendChild(wordEl);
    });

    // --- ADDED: GLOBAL TOUCH LISTENERS FOR THE DRAG PROCESS ---
    document.addEventListener('touchmove', e => {
        if (!draggedItem) return;
        // This part is for visual feedback (moving the element), which can be complex.
        // For now, we'll just track the position for the drop.
    }, { passive: false });

    document.addEventListener('touchend', e => {
        if (!draggedItem) return;
        draggedItem.classList.remove('dragging');

        // Find the element under the touch point
        const touch = e.changedTouches[0];
        const elementOver = document.elementFromPoint(touch.clientX, touch.clientY);
        
        // Use .closest() to find the parent .cell if we dropped on a child element
        const dropTarget = elementOver ? elementOver.closest('.cell') : null;

        if (dropTarget) {
            handleDropLogic(dropTarget, draggedItem.dataset.word);
        }
        
        draggedItem = null;
    });
}

restartBtn.addEventListener('click', generateGame);
</script>
</body>
</html>
